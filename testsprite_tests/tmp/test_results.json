[
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "09523d7b-26f6-44f3-a7ea-13594b52117a",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC001-Real-time stock update upon incoming order chat message",
    "description": "Verify that when an order chat message is detected, the stock inventory updates in real-time across all connected devices.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a second client tab and navigate to the same Manowzab URL to see if the SPA loads in a fresh tab (attempt natural navigation, not direct page manipulation). If the second tab is also blank, proceed with alternative troubleshooting (reload or report).\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/177070065262307//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.872Z",
    "modified": "2026-02-10T05:17:32.729Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "1ebcdb5c-f85c-4969-9766-d2c396e41527",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC002-Automated TTS announcement playback on new order",
    "description": "Confirm that the hybrid TTS system triggers playback of order summary announcements immediately when an order is processed online and falls back offline when unavailable.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Order announcement played via native TTS').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the hybrid TTS system to fall back to the native browser TTS and immediately play the order summary after network loss, but no native TTS playback indicator appeared within 3 seconds.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test steps could not be executed: the web application did not render any UI elements or controls on the page (blank SPA). No interactive elements, simulation controls, or visible endpoints found to simulate incoming order messages or to toggle network connectivity. Without UI controls or documented test endpoints, automated verification of: (1) Google Cloud TTS playback within 3 seconds when online, and (2) immediate native browser TTS fallback when offline, cannot be performed. Recommended next steps: (a) Confirm the SPA is running and rendering (check server logs or rebuild/start the frontend), (b) expose or provide test hooks/endpoints to simulate incoming order messages (e.g., a /simulate-order HTTP endpoint or a visible simulator control in the UI), and (c) provide a way to toggle network state or instructions for how to simulate offline mode for the app. After these are available, the test can be re-run to perform the two simulations and assertions.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770699971548699//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.876Z",
    "modified": "2026-02-10T05:06:11.664Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "6d23644e-4577-4659-a606-09021f27d949",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC003-Stock Grid color-coded availability and queue display",
    "description": "Validate that the Stock Grid correctly shows color codes for availability status and displays queue counts for items that are reserved but not yet finalized.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the current page (http://localhost:5173/manowzab-v4/) to attempt to initialize the SPA, then re-scan the page for interactive elements (Stock Grid and controls).\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt alternative navigation to load the SPA or reach a page that exposes the Stock Grid (navigate to http://localhost:5173/). If that fails, plan next: try /index.html or report website issue.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load the SPA by navigating directly to http://localhost:5173/manowzab-v4/index.html and then re-scan the page for interactive elements (Stock Grid and controls).\n        await page.goto(\"http://localhost:5173/manowzab-v4/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete validation: the Stock Grid UI never loaded. Actions attempted: navigated to the app root and index (4 navigations total), reloaded once, and waited (3s and 5s). Page remained blank (screenshot shows an empty white page) and there are 0 interactive elements, so automated checks (manual booking, color-code checks, queue-count checks) could not be run.\n\nWhat is blocking verification:\n- The SPA JavaScript did not initialize or failed to render any UI. No interactive elements were detected.\n\nRecommended next steps for troubleshooting (please perform or allow access to logs, then retry):\n1) Confirm the dev/server process is running and serving the app (restart the server if needed).\n2) Open browser developer tools (Console & Network) and check for JS errors or failed resource requests; share console errors or network failures if possible.\n3) Verify the app bundle is accessible (try loading the JS files referenced by index.html). If index.html is served but scripts 404, fix asset paths or build output.\n4) Try a direct navigation to the app on a different port or host, or try loading a static index.html copy to confirm the browser can render the page.\n5) If the app requires backend APIs, ensure those services are available (check network calls in DevTools).\n\nAfter the app is rendering, re-run the validation steps: (1) create queue reservations (admin proxy or grid controls), (2) confirm item color codes for in-stock / reserved (queued) / out-of-stock, (3) confirm queue count is shown next to queued items. The agent can retry the validation once the UI is visible.\n\nSuccess=false (validation not completed).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700089220053//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.880Z",
    "modified": "2026-02-10T05:08:09.322Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "f884fa0b-7c20-456c-a353-e89afbe86d59",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC004-Multi-device Firebase synchronization for stock, chat, and system state",
    "description": "Ensure all stock changes, chat messages, system toggles (like TTS, sound, away mode) are synced with under 100ms latency without data loss or duplicated messages across multiple devices.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app in two additional tabs (simulate 3 devices total) so each can be inspected and used for the sync test.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the SPA by waiting a short time and then reloading the current tab (navigate to the same URL). If the SPA still fails to load, attempt reloads on the other tabs or report website issue.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait 2 seconds then reload the current tab (navigate to the same URL) to attempt to load the SPA. If the page remains blank, prepare to reload the other tabs or report a website issue.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700663270522//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.886Z",
    "modified": "2026-02-10T05:17:43.382Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "bf800132-2605-4cf8-9992-c162eeea2273",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC005-Chat panel pagination and message formatting validation",
    "description": "Verify chat panel displays up to 200 messages with correct formatting for buy/sell/shipping message types and supports loading older messages via pagination.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the app root (http://localhost:5173/) to reload the SPA, then re-scan the page for interactive elements (chat panel, inputs, Load More).\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the app root to try to force the SPA to initialize (navigate to http://localhost:5173/). If the page remains blank, try opening the app in a new tab or report website issue.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app in a new tab to attempt forcing the SPA to initialize, then re-scan the page for interactive elements (chat panel, inputs, 'Load More'). If the page remains blank, report website issue.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700663158579//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.892Z",
    "modified": "2026-02-10T05:17:43.268Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "44f067b7-4cbd-42c4-88bf-4afce0e3afb1",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC006-Sales and chat history filtering and CSV export",
    "description": "Confirm that the History Modal correctly filters sessions by date and search terms and exports complete, accurate sales data as CSV.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the base URL (http://localhost:5173/) to attempt to load the SPA. If the page remains blank, try opening the site in a new tab or report a website issue.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the site in a new tab (http://localhost:5173/) to attempt loading the SPA and reveal interactive elements/history modal trigger.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Cannot complete History Modal tests because the SPA is blank and no interactive elements are present. Steps attempted: navigated to /manowzab-v4/, forced page refresh (F5), navigated to /, opened a new tab, waited 2s and 5s. Result: page remains blank (screenshot attached in session). Required UI interactions not started (0/6). Recommended next steps to resolve: 1) Confirm the local dev server is running (e.g., vite/webpack dev server). 2) Verify the correct port and URL (try http://127.0.0.1:5173/ and http://localhost:5173/). 3) Check browser console/network for errors and share logs or a screenshot of console output. 4) Disable extensions (adblock/privacy) that may block app assets. 5) If using a build, ensure index.html and assets are being served. After these are addressed, re-run the test and the following will be executed: open History Modal, set date filters, apply text search, verify transactions and stats, click CSV export, validate CSV contents. Unable to confirm filtering or CSV export at this time. Please fix the site availability or provide an accessible URL; then request retry. ",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700075920839//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.897Z",
    "modified": "2026-02-10T05:07:56.032Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "94d868c9-6e82-4a46-beb5-9f2f0f688895",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC007-iPad Safari audio unlock enabling autoplay on first interaction",
    "description": "Test that audio playback (TTS and sound effects) on iPad Safari is successfully unlocked after the user's first interaction, allowing autoplay throughout the session.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the current page (navigate to the same URL) to attempt to force the SPA to load so interactive elements appear.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the site root in a new tab to check for server/index or alternate entry point and look for any visible UI or diagnostics that reveal why the SPA is blank.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the site root (http://localhost:5173/) in the current tab to look for server/index or diagnostics that explain the blank SPA, then re-check for interactive elements.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the app's index.html (http://localhost:5173/manowzab-v4/index.html) in the current tab to check for a static entry/diagnostic page and reveal any content or errors.\n        await page.goto(\"http://localhost:5173/manowzab-v4/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Audio playback unlocked').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the app to show that audio playback was unlocked after the user's first interaction so TTS and sound effects could autoplay for the session, but the 'Audio playback unlocked' indicator did not appear (playback may still be blocked)\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete the requested audio-unlock test: the application page (http://localhost:5173/manowzab-v4/index.html) is blank and contains no interactive elements, so a user interaction to unlock audio cannot be performed. Actions already attempted: opened app and root URLs, reloaded, waited (3 times), and scrolled (2 times). Recommended next steps to resolve the blocker before resuming the test:\n- Verify the local dev server is running and serving the SPA (check terminal where server is started).\n- Open the page in a regular browser and inspect the developer console for JS errors (console/network) that prevent the SPA from rendering.\n- Confirm build artifacts exist (index.html references, JS bundles) and that the correct base path is configured for /manowzab-v4/.\n- If CORS or asset 404 errors appear, fix server/static path settings and reload.\n- Once the SPA renders and interactive controls appear, re-run the test: 1) confirm initial autoplay is blocked, 2) perform a tap/click to unlock audio, 3) verify TTS and sound effects play without further interaction.\nCurrent result: test not performed due to blank page. Please fix server/UI rendering or provide an accessible build; then request continuation. \nTest completed: NO (success=false).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700171768498//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.902Z",
    "modified": "2026-02-10T05:09:31.876Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "52b63cd1-b5d1-49ad-adff-550317f3f990",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC008-Sound effect playback for success and error events",
    "description": "Ensure that distinct sound effects play appropriately on successful order processing and error occurrences.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the app (force a navigation) to attempt to load the SPA, then re-check the page for interactive elements.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Force-reload the SPA by navigating to http://localhost:5173/manowzab-v4/ (go_to_url) to attempt to load the UI, then re-check the page for interactive elements to trigger the success and error events.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app in a new tab to attempt to load the SPA and reveal interactive elements so the success/error events can be triggered.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Success sound effect played once').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that a success sound effect played exactly once after triggering a valid chat order, but the page did not show the expected confirmation text indicating the success sound was played.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test run aborted - SPA did not render so the required interactions and sound assertions could not be performed.\n\nSummary of attempts:\n- Visited: http://localhost:5173/manowzab-v4/ (3 navigation attempts)\n- Waits: 3s and 5s\n- Opened a new tab to the same URL\n- Observed page: blank / no interactive elements (0 inputs/buttons/links)\n- Event triggers executed: 0/2 (success order, error state)\n- Assertions executed: 0/2 (success sound, error sound)\n\nOutcome: The required checks (playback of success and error sound effects) were not executed because the app UI did not load. Recommendation: Verify that the local dev server is running and serving the SPA at http://localhost:5173/manowzab-v4/, check the browser console and network tab for errors (missing assets, 404s, CORS, or bundle failures), then retry. Alternatively provide an accessible staging URL or start the application; once the UI renders, re-run this test to trigger a successful order and an error state and assert the sounds play exactly once each.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700076524858//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.907Z",
    "modified": "2026-02-10T05:07:56.627Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "47e664ae-bd0f-4943-b270-494b0911d4b2",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC009-YouTube Live Chat API polling respects quota and handles errors gracefully",
    "description": "Validate that the YouTube Live Chat API polling mechanism limits request frequency to avoid quota breaches and recovers smoothly from API errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the SPA (navigate to the same URL) to attempt to force the app to load, then re-scan the page for interactive elements or logs to proceed with the YouTube Live Chat polling validation.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab to the app root (http://localhost:5173) to try loading the SPA in a fresh tab and then re-scan for interactive controls or logs; if that fails, try alternate entry (index.html) or report website issue.\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to an alternative entry (index.html) to force the SPA to load, then re-scan the page for interactive elements or visible logs.\n        await page.goto(\"http://localhost:5173/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:5173/manowzab-v4/index.html in the current tab and re-scan the page for interactive elements or visible logs to proceed with the YouTube Live Chat polling validation.\n        await page.goto(\"http://localhost:5173/manowzab-v4/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Polling adjusted to respect quota limits and resumed after API error').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the YouTube Live Chat polling mechanism to dynamically reduce request frequency to avoid exceeding API quota and to resume normal polling after simulated API errors, but the page did not display the success indicator 'Polling adjusted to respect quota limits and resumed after API error'.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final report - YouTube Live Chat polling validation NOT completed (success=false).\n\nTask requested:\n- Validate that the YouTube Live Chat API polling mechanism limits request frequency to avoid quota breaches and recovers smoothly from API errors.\nPlanned test steps (not executed because app inaccessible):\n1) Simulate continuous high-frequency polling to observe rate-limiting/backoff.\n2) Verify polling interval adjusts dynamically to avoid quota breaches.\n3) Introduce artificial API errors (HTTP 403 and 500) to test error handling.\n4) Verify errors are logged, users are notified if required, and polling resumes normally after cooldown/backoff.\n\nWhat was attempted:\n- Multiple navigations to the app root and alternative entry points were performed to load the SPA: /, /manowzab-v4/, /index.html, /manowzab-v4/index.html (6 navigations total across attempts).\n- A new browser tab was opened to the app once.\n- Waited for the SPA to load (3s and 5s waits recorded).\n- Captured a screenshot showing a blank/white page. Page analysis: 0 links, 0 interactive elements, 0 iframes.\n- Attempted to file a website-issue report; this action failed twice with internal error: 'str' object has no attribute 'error'.\n\nObserved outcome:\n- The SPA did not render in the browser; no interactive elements or controls were detected. Because the UI was unreachable, none of the validation steps could be executed (0 of 4 tests completed).\n- Internal reporting failed due to a string-handling error while trying to report the website issue.\n\nDiagnostics & recommended next steps for operator/developer to allow completion of the validation:\n1) Confirm the dev server is running and serving the SPA at the expected port/path (http://localhost:5173 and subpath /manowzab-v4/).\n2) Check browser console and server/build logs for runtime errors that prevent SPA rendering (provide console errors and build logs). Attach those logs in the next message.\n3) Verify that index.html and static assets are accessible (try accessing the JS bundle URL directly). If using a SPA base path, confirm correct base href or routing config.\n4) Provide an alternate test endpoint (a staging URL or a mock UI) that renders in the browser, or provide network-accessible API endpoints and test credentials so polling behavior can be simulated off-browser.\n5) If the UI requires authentication or a specific environment variable, provide test credentials or a test environment that allows the agent to proceed.\n6) If desired, provide a minimal reproducible page or a JSON endpoint that simulates the YouTube Live Chat API so the polling/backoff logic can be exercised without the full SPA.\n\nWhat will be done once the app is accessible or logs/alternate endpoint provided:\n- Simulate a high-frequency polling loop and observe request timing and backoff behavior.\n- Verify dynamic adjustment of polling interval to respect YouTube quota limits.\n- Inject 403/500 responses (or mock them) and confirm error logging, user notifications (if implemented), and that polling resumes correctly after cooldown using exponential backoff or configured retry logic.\n- Produce a detailed test log, timing graphs, and recommendations to fix any quota or recovery issues.\n\nCurrent status: Validation not performed due to inaccessible SPA. Agent terminated per user instruction. Please supply server/console logs, enable the SPA to render at the given URL, or provide an alternate test endpoint and the validation will be retried.\n\nErrors encountered during this session:\n- SPA blank/white page (no interactive elements detected).\n- Internal error while reporting site issue: 'str' object has no attribute 'error'.\n\nAttachments: screenshot of the blank page was captured during investigation (available in session).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700214618294//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.912Z",
    "modified": "2026-02-10T05:10:14.728Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "60784bee-4abf-46f8-ba7e-d7d05302bf48",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC010-Away mode toggle and custom away message display with visual banner",
    "description": "Confirm that toggling away mode updates system state, broadcasts custom away messages, and displays a visible banner as expected.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt a direct navigation to the root URL (http://localhost:5173) to force the SPA to load, then wait 2 seconds and re-check for header controls.\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try direct navigation to the app's index page (http://localhost:5173/index.html) to force the SPA to load, then wait and re-check for header controls.\n        await page.goto(\"http://localhost:5173/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Away Mode Enabled').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that toggling Away Mode updates the system state, broadcasts the custom away message, and displays a visible away banner ('Away Mode Enabled'). The banner did not appear, so away mode may not have been activated or the notification/banner broadcast failed.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete the requested verification because the web app UI did not load. Observations and attempts:\n- Page loaded shows a blank white screen (screenshot attached in session). No interactive elements (header controls, links, or chat UI) were detected by the automation environment.\n- Actions attempted: navigated to three URLs (/, /manowzab-v4/, /index.html), reloaded page with Ctrl+R once, waited three times (2s each), and scrolled once. None exposed the UI controls required to toggle away mode or observe banners/messages.\n- Result: 0 of 5 test steps completed. The environment is blocked by an unreachable SPA.\nWhat is blocking progress:\n- The SPA appears not to be running/serving UI on the provided localhost URLs, or the page is failing to render (blank white). Without any interactive elements the test cannot proceed.\nRecommended next steps to allow continuation:\n1) Confirm the local server is running and serving the application at http://localhost:5173. If not running, start the server and retry. 2) If the app uses a different path/port, provide the correct URL. 3) Check the browser devtools console for runtime errors and fix them (frontend build errors, missing assets, CORS issues, etc.). 4) If UI requires authentication, provide test credentials or open the public test route. 5) If preferred, allow the automation to try a go_to_url to a specific debug/test page or open a new tab with an alternate URL.\nNext actions once the app is reachable:\n- Toggle away mode on via header controls.\n- Verify the custom away message is broadcast as a chat notification.\n- Confirm the away banner is visible on connected devices.\n- Toggle away mode off and verify banner removal and normal chat behavior.\nStatus: Request not completed due to UI not loading. Please resolve the app availability and then re-run the test.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700120368803//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.917Z",
    "modified": "2026-02-10T05:08:40.475Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "4f4275d4-874b-4163-ae92-cbc2aa24968b",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC011-Offline caching and update prompt functionality of PWA",
    "description": "Verify that the Progressive Web App caches critical assets for offline use and displays an update prompt when a new version is available.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the web app manifest to look for PWA metadata (start_url, service worker info) and then fetch service worker script to inspect cached assets.\n        await page.goto(\"http://localhost:5173/manowzab-v4/manifest.webmanifest\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fetch the service worker script(s) to inspect cache names and the list of cached assets. Start by requesting /manowzab-v4/sw.js, then /manowzab-v4/service-worker.js, then /sw.js (open each in same tab). If any script is found, extract its contents to look for cache names and asset lists.\n        await page.goto(\"http://localhost:5173/manowzab-v4/sw.js\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5173/manowzab-v4/service-worker.js\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5173/sw.js\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the link to /manowzab-v4/sw.js visible on the current page to open the service worker script and extract cache names and cached asset lists (look for caches.open/cache names, precache arrays, or workbox manifest).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the app's index HTML to locate the service worker registration and correct service-worker path (load /manowzab-v4/index.html). If index.html contains the sw path, fetch that script to extract cache names and precache lists.\n        await page.goto(\"http://localhost:5173/manowzab-v4/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=New version available  Refresh to update').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test expected the PWA to display an update prompt ('New version available  Refresh to update') after deploying a new version and reloading, but no such prompt was found. This indicates the service worker did not detect the new version or the app failed to notify the user about the available update.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification incomplete - required PWA resources could not be read or tested. Summary of findings and blockers:\n\n- Manifest fetch: GET /manowzab-v4/manifest.webmanifest returned empty/truncated content; no manifest JSON could be extracted (see extracted_content_0.md).\n- Index HTML: GET /manowzab-v4/index.html returned an empty/truncated page; no <link rel=\"manifest\"> or serviceWorker registration snippets were found in the provided content (see extracted_content_1.md).\n- Service worker scripts: Attempts to load /manowzab-v4/sw.js, /manowzab-v4/service-worker.js, and /sw.js returned non-script/server-notice pages or otherwise unusable responses (no usable service-worker script content available). Repeated attempts to fetch the same scripts have been avoided per retry rules.\n- SPA root: The app root rendered blank (no interactive elements), preventing in-browser verification steps such as disconnecting the network and reloading or observing an update prompt.\n\nWhat is needed to complete verification:\n1) Ensure the server serves the manifest and service-worker files with their full content at the expected URLs (for example: /manowzab-v4/manifest.webmanifest and /manowzab-v4/sw.js). Confirm that these endpoints return the full JSON/script text rather than a server notice or truncated payload.\n2) If server-side fixes are not possible, provide the raw contents of the manifest.webmanifest and the service-worker script(s) (sw.js / service-worker.js / precache-manifest.*.js) for analysis.\n3) Once the files are accessible, the following checks will be performed: extract manifest fields (start_url, scope, icons, display, etc.), inspect service-worker for caches.open/caches names, precache arrays or workbox precache manifest, test offline behavior by disconnecting and reloading to confirm cached assets load, and deploy a new version to verify that an update prompt is shown.\n\nAttached files from attempted extraction (logs):\n- extracted_content_0.md (manifest attempt - empty/truncated)\n- extracted_content_1.md (index.html attempt - empty/truncated)\n\nResult: success=false (verification could not be completed due to inaccessible/empty resources).\n\nAttachments:\n\nextracted_content_0.md:\n<url>\nhttp://localhost:5173/manowzab-v4/manifest.webmanifest\n</url>\n<query>\nExtract the full manifest content displayed on this page. Return the raw manifest JSON and then clearly list the values for: name, short_name, start_url, scope, display, background_color, theme_color, icons (each icon's src, sizes, type), related_applications, gcm_sender_id (if present), and any fields that reference service worker scripts or service-worker-related paths. If any URLs are present, include them.\n</query>\n<result>\nManifest JSON: Not present in the provided page content.\n\nValues (all fields not found in the provided page content):\n- name: Not present\n- short_name: Not present\n- start_url: Not present\n- scope: Not present\n- display: Not present\n- background_color: Not present\n- theme_color: Not present\n- icons: Not present\n  - (no icon objects with src, sizes, type found)\n- related_applications: Not present\n- gcm_sender_id: Not present\n- Service worker / service-worker-related fields or script references: Not present\n- URLs: No URLs present in the provided content\n\nNote: The provided webpage content is empty/truncated. To continue from a specific position in the original page, provide the start_from_char parameter.\n</result>\n\nextracted_content_1.md:\n<url>\nhttp://localhost:5173/manowzab-v4/index.html\n</url>\n<query>\nExtract the full HTML/text content of the current page (/manowzab-v4/index.html). From the HTML, identify and list: 1) any <link rel=\"manifest\" href=\"...\"> occurrences and the href value(s); 2) any navigator.serviceWorker.register(...) calls and the path(s) registered; 3) any importScripts(...) or workbox.* usage or precache manifest references and the script paths; 4) any references to service-worker files (e.g. sw.js, service-worker.js) or directories; and 5) meta tags for theme_color/background_color. Provide the raw HTML content first and then a clear extracted list of the found items and their values/URLs. Include line/context snippets where possible. Set extract_links=true.\n</query>\n<result>\nRaw HTML content (as provided):\n<empty  no HTML content was included in the webpage_content>\n\nExtracted items (from the provided content):\n\n1) <link rel=\"manifest\" href=\"...\">\n- None found in the provided content.\n\n2) navigator.serviceWorker.register(...) calls\n- None found in the provided content.\n\n3) importScripts(...), workbox.* usage, or precache manifest references\n- None found in the provided content.\n\n4) References to service-worker files or directories (e.g., sw.js, service-worker.js)\n- None found in the provided content.\n\n5) meta tags for theme_color / background_color\n- None found in the provided content.\n\nNotes:\n- The provided webpage content appears empty/truncated. If more content exists, supply the page HTML starting from a character offset using start_from_char so extraction can continue.\n- extract_links=true.\n</result>",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/177070017630494//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.923Z",
    "modified": "2026-02-10T05:09:36.420Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "8eea1e9a-146e-471b-9133-325e8916988c",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC012-Manual booking and queue management via stock grid inputs",
    "description": "Test that admins can manually book stock items and manage queues through Stock Grid controls and that these updates reflect in real-time.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the app URL with a cache-busting query parameter to force a full reload and attempt SPA load, then re-check for interactive elements.\n        await page.goto(\"http://localhost:5173/manowzab-v4/?reload=1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab to the root server URL (http://localhost:5173/) to try a different entrypoint for the SPA and check for interactive elements.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate the current tab to the server root (http://localhost:5173/) to try a different entrypoint and force the SPA root load, then re-check the page for interactive elements.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Booking Confirmed: Queue and Stock Updated').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that manually booking a stock item updates the queue count and available stock in real-time (and that cancelling adjusts them and synchronizes across devices), but the expected confirmation/update text did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test cannot proceed: Manowzab Command Center SPA failed to render and page is blank/white. Summary of troubleshooting already performed: navigated to the app (including cache-busted URL), reloaded the page, waited multiple times, and opened a fresh root tab  none produced interactive elements. Evidence: current screenshot is blank and browser_state shows 0 interactive elements. Result: automated test steps (select item, book quantity, verify queue updates, cancel queue, confirm sync) could not be executed. Requested next steps for user/developer to allow continuation: 1) Confirm the local dev server is running and listening on http://localhost:5173 (run the dev/start command). 2) Open browser devtools (Console and Network) and share any errors (JS exceptions, failed network requests, 404/500) or server logs. 3) If the app uses a backend, ensure backend services are running and accessible. 4) If a different URL or port should be used, provide it. 5) If desired, grant permission to run a website-issue report action and include any console/network logs. When the app renders and interactive elements appear, re-run the test steps; at that point the automated flow will: (1) select a stock item and input booking quantity, (2) verify queue and stock availability update, (3) cancel part/all of the queue via Stock Grid controls, (4) confirm adjustments and synchronization across devices. Since the SPA did not load, success=false and no test steps could be completed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700148907538//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.927Z",
    "modified": "2026-02-10T05:09:09.014Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "ee09c482-f566-4ce7-860f-80cd37158a43",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC013-Pull-to-refresh gesture on mobile reloads chat and stock data",
    "description": "Validate the pull-to-refresh gesture on mobile devices triggers reload of latest chat messages and stock data without errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the page (navigate to the same URL) to force the SPA to load, then re-check the page for interactive elements and the chat/stock UI.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading the app from the root URL to force the SPA to initialize. If that loads, locate the chat panel and perform the pull-to-refresh gesture next.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the app's index file directly to force SPA/static assets to load (navigate to /manowzab-v4/index.html). If still blank, prepare to report a website issue.\n        await page.goto(\"http://localhost:5173/manowzab-v4/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Chat and stock data refreshed successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Pull-to-refresh was expected to reload the latest chat messages and refresh the stock grid without duplicates or missing entries, but the confirmation 'Chat and stock data refreshed successfully' did not appear  the refresh likely failed or the UI did not update\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final report (task incomplete):\n\nRequested task: Validate the pull-to-refresh gesture on mobile devices triggers reload of latest chat messages and stock data without errors.\n\nWhat was attempted:\n- Step 1 (Open the app on a mobile/tablet device): Attempted and navigation requests executed to the app. Visited URLs: http://localhost:5173, http://localhost:5173/manowzab-v4/, http://localhost:5173/, and http://localhost:5173/manowzab-v4/index.html.\n- Waits performed to allow SPA load: 3 seconds then 5 seconds (2 waits total).\n- Reloads/navigation attempted multiple times as above.\n- Attempted to submit a website issue from the agent; that attempt produced an error: 'str' object has no attribute 'error'.\n\nObserved result:\n- The page remained blank (white) and the DOM contained no interactive elements. Screenshot shows an empty white page. No chat panel, no stock grid, and therefore no elements to interact with.\n- Because the SPA never rendered, pull-to-refresh could not be performed and chat/stock refresh behavior could not be observed or validated.\n- Interactive element count: 0. Task progress: 1 of 4 steps completed. Remaining validations (3) not executed.\n\nErrors / unexpected behavior encountered:\n- SPA failed to initialize/render on the visited URLs (blank page / empty DOM).\n- Report attempt from the agent failed with 'str' object has no attribute 'error' (internal error while trying to file issue).\n\nImmediate impact on requested validation:\n- Cannot perform pull-to-refresh gesture on chat panel because UI is not present.\n- Cannot verify chat refresh, cannot verify stock grid refresh, and cannot confirm absence of duplicates or missing data.\n\nRecommended developer debugging steps (to fix the blank SPA so the validation can be re-run):\n1) Confirm the development/production server is running and serving JS bundles and static assets for the manowzab-v4 app.\n2) Open browser DevTools (Console) to capture JavaScript runtime errors (missing files, syntax errors, runtime exceptions). Capture and share console logs.\n3) Check Network tab for failed requests (404/500) for JS/CSS/asset files; ensure correct base path and that build assets are present at expected locations.\n4) Verify index.html base href and routing configuration (the app uses /manowzab-v4/  confirm assets are served relative to that path or adjust base path).\n5) Check server logs for errors serving files (permissions, missing files, misconfigured static middleware).\n6) Disable service worker or clear caches (stale service worker can cause blank loads). Clear browser cache and try again.\n7) Check for CSP or other policies blocking script execution.\n8) If using a reverse proxy (nginx, etc.), verify correct asset forwarding and that no path rewriting breaks asset URLs.\n9) Try loading the raw index.html response and view source to ensure the page includes script tags and not an empty file.\n10) Reproduce on both desktop and mobile/emulator; test with developer tools device emulation and a real mobile device.\n\nAfter fixes, suggested validation steps to re-run (exact steps to confirm the pull-to-refresh behavior):\n1) Open the app on a mobile/tablet device or emulator.\n2) Locate the chat panel and note current message list and stock grid state (take screenshots or export lists/counts/timestamps).\n3) Perform a pull-to-refresh gesture on the chat panel (swipe down until refresh indicator appears, then release).\n4) Observe network requests triggered by the refresh and confirm API responses succeed (200) and update data.\n5) Verify new chat messages appear and the stock grid updates to reflect current stock status.\n6) Confirm no duplicate messages or duplicate stock items: compare message IDs/timestamps and stock item IDs/counts before and after refresh.\n7) Repeat refresh multiple times (e.g., 3 times) to check for idempotency and no duplicate insertion.\n8) Record console logs during refresh to capture any errors or warnings.\n\nConclusion:\n- The validation could not be completed because the SPA did not render (blank page). All subsequent steps are blocked. Developer action is required to restore the SPA assets and resolve runtime errors. Once the app loads, re-run the outlined validation steps.\n\nAgent task completion status: INCOMPLETE. Please fix the app rendering issues and re-run the test. Include console/network logs when requesting further validation assistance.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700251586747//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.932Z",
    "modified": "2026-02-10T05:10:51.698Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "3942bc80-f0a0-4ebf-b014-d314f7e9f75d",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC014-Voice-price detection processes spoken price queries with TTS response",
    "description": "Ensure that spoken price queries on the Voice Price Page are detected accurately by speech recognition and the corresponding price information is announced using TTS.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the app URL (http://localhost:5173/manowzab-v4/) to force SPA to load, then re-check the page for interactive elements or a link/menu to the Voice Price Page.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the Voice Price Page URL (last-resort navigation) and then re-check the page for interactive elements or voice controls.\n        await page.goto(\"http://localhost:5173/manowzab-v4/voice-price\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=The price of Test Item is $9.99').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected speech recognition and TTS to announce the correct price ('The price of Test Item is $9.99') after speaking a valid price query on the Voice Price Page, but the announcement did not appear within 3 seconds\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test aborted  unable to perform speech-recognition and TTS verification.\n\nSummary of what was attempted:\n- Navigated to the app root (http://localhost:5173).\n- Waited 2s, then 3s to allow the SPA to load.\n- Scrolled the page (10 pages) and waited 2s.\n- Reloaded to http://localhost:5173/manowzab-v4/ to force SPA load.\n- Finally navigated to http://localhost:5173/manowzab-v4/voice-price (the Voice Price Page).\n\nObserved problem:\n- The page is blank (screenshot shows a white page) and contains 0 interactive elements. The SPA did not render on any of the navigation attempts. Because no UI elements or voice controls are available, automated steps to speak a valid query, verify speech recognition, and confirm TTS playback cannot be executed.\n\nWhy the task could not be completed:\n- Speech test requires visible/interactive voice controls or JS to run on the page. The applications client-side code appears not to have loaded or the dev server is not serving the SPA correctly.\n\nRecommended next steps for the user to enable testing:\n1) Confirm the local dev server is running and serving the SPA (check terminal for errors).\n2) Ensure the correct base path and build are used (manowzab-v4). Try opening the app in a regular browser and check devtools console/network for JS errors or 404s.\n3) If the app uses a different port or path, provide the correct working URL.\n4) If CORS or file permissions block JS, fix those and reload.\n5) Once the page renders and the voice controls are present, request the test again; the remaining steps are: 5 tests (navigate & speak valid query, verify speech recognition, confirm TTS playback, speak invalid query, verify error TTS).\n\nStatus: success=false  testing cannot proceed until the page renders. If the user prefers, provide a working URL or grant access to a hosted instance and automated testing will resume.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/1770700140979715//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.936Z",
    "modified": "2026-02-10T05:09:01.092Z"
  },
  {
    "projectId": "188a0919-e33b-4bc7-ab98-1076e22b0492",
    "testId": "b42c4341-04d5-4e96-b509-67a235a8ef4d",
    "userId": "9448f488-3041-7031-4f14-e580690284c6",
    "title": "TC015-System reliability under high load with 500+ chat messages and 70 stock items",
    "description": "Test the application stability and UI responsiveness when handling large volumes of chat messages and extensive stock inventory without memory leaks or lag.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the SPA using a direct navigation (last-resort) to force the app to reinitialize, then re-evaluate the page for interactive elements and visible UI components.\n        await page.goto(\"http://localhost:5173/manowzab-v4/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly, then force a direct navigation to the app root (http://localhost:5173/) to try to reload assets and reinitialize the SPA, then wait again to allow rendering.\n        await page.goto(\"http://localhost:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab and navigate to http://127.0.0.1:5173/, wait for the SPA to load, then re-evaluate the page for interactive elements and visible UI components.\n        await page.goto(\"http://127.0.0.1:5173/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Stability Test Passed: UI responsive with 500+ messages and 70+ items').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The stability confirmation ('Stability Test Passed: UI responsive with 500+ messages and 70+ items') did not appear after populating 500+ chat messages and loading 70+ inventory items; the UI may have frozen, experienced data loss, or exhibited memory leaks\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test run aborted: the application UI never loaded so automated stability tests could not start.\n\nWhat was attempted:\n- Repeated navigation to the app root and route (http://localhost:5173 and /manowzab-v4/) and to 127.0.0.1:5173.\n- Multiple waits and a manual refresh (F5).\n- Opened a new tab to 127.0.0.1:5173 and waited.\n- Observed blank white page with 0 interactive elements and no UI controls available for testing.\n\nResult:\n- Unable to populate chat messages, load inventory items, or run the 30-minute monitoring because the SPA never rendered. All test steps remain unexecuted.\n\nSuggested next steps to enable automated testing:\n1) Verify the web application server is running and serving assets on port 5173 (start the dev/prod server if stopped). 2) Open the browser developer console and network panel to check for console errors, missing JS/CSS assets, or failing network requests (404/500/CORS). 3) Confirm the correct base route (root vs /manowzab-v4/) and try that exact URL after server restart. 4) Ensure any required backend (API/websocket) services are running and reachable. 5) If available, provide an alternative reachable URL or a packaged build (staging) for testing. 6) Once the app renders, re-run the automated test to: populate 500+ messages, load 70+ inventory items with realtime updates, and monitor UI/memory for 30 minutes.\n\nIf continued assistance is desired after addressing the above, provide access to a working URL or confirm the server is running and the app renders; automated tests will be restarted then.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/9448f488-3041-7031-4f14-e580690284c6/177070027938269//tmp/test_task/result.webm",
    "created": "2026-02-10T05:05:15.940Z",
    "modified": "2026-02-10T05:11:19.501Z"
  }
]
